\documentclass[12pt]{article}
\usepackage{standalone}
\usepackage{mystyle}

\begin{document}

\tableofcontents


\include{11.tex}
\include{17.tex}




\begin{figure}[] 
\centering
\includegraphics[width = 0.4\textwidth]{c}
\caption{For the brave and true}
\label{fig:my_label}
\end{figure}



\section{Hello World}
\noindent
\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
(ns p1.core
  (:gen-class))

(defn -main
  "I don't do a whole lot ... yet."
  [& args]
  (println "Hello, World!"))

; This is Clojure
; yes this is generated by lein, so no ref
\end{minted}
\\
\hline
Compile and run: \\make sure that you have started the project with \texttt{lein}, and then do\\
\texttt{\$ lein run}\\
\texttt{Hello, World!}\\
\hline
\texttt{lein} tutorial is here: \cite{1_github_2015}\\
\hline
\end{tabular}




\section{Phase 2: Paradigms and Features}


{\it What paradigms is your language? What features of the language support your answer? Match specific features to specific paradigms. }

\vspace{10pt}
\question{Answers}

Clojure is a dynamic languange, and it belongs to the following paradigms: functional, (beyond) object-oriented and concurrent programming.

\part{Dynamic}

Clojure, like its parent Lisp, is first and foremost a dynamic language \cite{clojuredyn}. Our text may not have listed being dynamic as one of the paradigms, but it is one of the most important features of Clojure. A dynamic language determines many more things at run-time than in compile time \cite{rathore2011clojure}. 

\begin{itemize}
\item Clojure does not require type declaration \cite{rathore2011clojure}.
\item Clojure has an \texttt{eval} function to load code for execution in run-time, a feature most static languages lack \cite{rathore2011clojure}. 
\item REPL, Read-Eval-Print-Loop, is the primary interface for programming in Clojure. It is a console for entering and executing commands \cite{clojuredyn}.
\item Clojure is compiled, but REPL automatically "compiles to JVM bycode on the fly" \cite{clojuredyn}. 
\end{itemize}

\part{Functional programming}

According to the textbook, a functional language is based on functions over types such as lists and trees. Clojure is a dialect of Lisp,  a classical functional language. Clojure is suited for developing significant programs without having mutable variables, as it possesses, but not limited to, the following characteristics:

\begin{enumerate}

\item Clojure functions are {\it first-class functions}. Like the more familiar integer or boolean objects, Clojure functions can be created, stored, used as function arguments and returned by other functions \cite{fogus2014joy}. In addition, it is easy to use high order functions like \texttt{map, reduce, filter} \cite{rathore2011clojure}.

% \noindent
% \begin{tabular}{|p{0.8\textwidth}|}
% \hline
% \begin{minted}{clj}
% ; CIDER 0.8.1 (package: 20141120.1746)
% ; (Java 1.8.0_60, Clojure 1.7.0, nREPL 0.2.10)

% ;; fn creates a function object, 
% ;; the object is stored in var called answer
% user> (def answer (fn [] "42")) 
% ;; see, anonymous function! With an empty body!
% #'user/answer
% user> (answer)
% "42"
% \end{minted}
% \\
% \hline
% To run: in Emacs, \texttt{M-x}, select cider-jack-in\\
% For installing Cider in Emacs, steps see \cite{brave2015}\\
% \hline
% Adapted from \cite{hickey2009clojure}\\
% \hline
% \end{tabular}

\item Clojure has a fine selection of {\it immutable}, persistent data structures. Imperative languages feature the use of variables and manipulation of memory contents. By comparison, the values in Clojure is immutable \cite{fogus2014joy}; a var in Clojure is the closest thing to a variable in imperative languages \cite{fogus2014joy}.
        
% \noindent 
% \begin{tabular}{|p{0.8\textwidth}|}
% \hline
% \begin{minted}{clj}
% ;; Using def keyword to create a var in Clojure
% (def x 42)

% ;; immutable vector
% user=> (def v [42, 1024]) 
% #'user/v

% ;; Use metadata 
% ;; to associate attributes to logical data.
% user=> (def v-deco (with-meta v {:answer :p}))
% #'user/v-deco
% user=> (:source (meta v-deco))
% nil
% user=> (= v v-deco)
% true

% \end{minted}
% \\
% \hline
% To run:\\
% \texttt{\$ lein repl}\\
% Enter the code at the REPL prompt.\\
% \hline
% See \cite{fogus2014joy}.\\
% \hline
% \end{tabular}

\item {\it Lazy eval}: Clojure sequences are lazy, meaning that the elements are only computed when needed. It is thus possible to create list of infinite length \cite{rathore2011clojure}. 

\item {\it Anonymous functions}: the keyword \texttt{fn} mentioned above created a function without a name. It takes a {\it special form} in Clojure syntax, because it is not defined in terms of functions, types or macros \cite{fogus2014joy}.


\item {\it Recursive looping}: since Clojure does not employ mutable local variable, its implementation of {\it for} or {\it while} loop is different from imperative languages with changing states \cite{clojurefn}.

% \begin{tabular}{|p{0.8\textwidth}|}
% \hline
% \begin{minted}{clj}
% (defn train ;; define a function, train
%     [x]     ;; that takes one argument
%     (when (pos? x)  ;; when x is positive
%       (println "Choo choo!")
%       ;; recur is a special form that does
%       ;; __tail recursion__
%       (recur (dec x)))) 
% \end{minted}
% \\
% \hline
% \begin{minted}{clj}
% clojure-noob.core> (train 3)
% Choo choo!
% Choo choo!
% Choo choo!
% nil
% \end{minted}
% \\
% \hline
% To run: in Emacs, \texttt{M-x}, select cider-jack-in\\
% Then do \texttt{C-c C-k} to compile the current buffer\\
% For using cider in Emacs, see \cite{brave2015}\\
% \hline
% Adapted from \cite{fogus2014joy}\\
% \hline
% \end{tabular}


% \item Lambda calculus
% \item Lazy evaluation
\end{enumerate}

\part{Beyond Object-oriented}

Imperative programming views everything as object with mutable states; in comparison, Clojure sees the world in terms of time, state and identity. The OO in a traditional sense has traits of imperative programming baked in, contrary to Clojure's philosophy \cite{fogus2014joy}. Clojure has a "broad support" for various paradigms \cite{rathore2011clojure}; it can implement useful aspects in OO with its functional focus and immutability features. \cite{fogus2014joy}.


\begin{enumerate}
\item { \it Polymorphism} makes the system extensible and flexible. Clojure's {\it multimethods} separates polymorphism from OO and types \cite{clojurerationale}. Instead of having a new data type for a new situation, Clojure would rather use a large collection of functions operating on a small set of data types. See the multimethods page on \cite{hickey2009clojure}.



\item {\it Abstraction-oriented}: Clojure provides the option of {\it ad hoc} hierarchy; this form of inheritance relationship can be defined among data types and even symbols. The Clojure equivalent of interface is called \texttt{protocol}.


% \begin{tabular}{|p{0.8\textwidth}|}
% \hline
% \begin{minted}{clj}
% ;; Defining a relationship
% ;;between ::osx and ::unix
% (derive ::osx ::unix)

% ;; Protocol
% (defprotocol Walkable
%   (do-walking [x] "Go on")
%   (feelings-about [x] [x y] "Inner depths"))
% \end{minted}
% \\
% \hline
% From \cite{fogus2014joy} and \cite{brave2015}\\
% \hline
% \end{tabular}


\item {\it Encapsulation} hides the implementation details and enhances levels of abstraction. Clojure accomplishes encapsulation by immutability, closures and name spaces \cite{relevance}.



\end{enumerate}




\part{Concurrent programming}

Concurrency is easy to implement with Clojure. Since Clojure runs on JVM, it uses JVM threads. Clojure has language-level support for safe and lock-free concurrency \cite{rathore2011clojure}.
Its basic tools for concurrency include \texttt{future}, \texttt{delay} and \texttt{promise}, which are all macros built in \texttt{clojure.core} \cite{brave2015concur}.






% \begin{tabular}{|p{0.8\textwidth}|}
% \hline
% \begin{minted}{clj}
% ;; Spawn a thread to print
% (future (Thread/sleep 1000)
%     (println "I got printed 1s after"))
% ;; but this line is not blocked
% (println "I appear immediately")
% \end{minted}
% \\
% \hline
% \begin{minted}{clj}
% clojure-noob.core> I appear immediately
% I got printed 1s after
% \end{minted}
% \\
% \hline
% Run the code in REPL in Emacs, as instructed in \cite{brave2015} \\
% \hline
% Code adapted from \cite{brave2015concur}\\
% \hline
% \end{tabular}



Clojure provides four mechanisms that ensure {\it controlled} state changes:
\begin{enumerate}
\item {\it Macros} such as ref, set, dosync expose Clojure's software transaction memory (STM). This feature supports sharing changing states synchronously, in coordination.
\item The {\it Agent} system also provide access to mutable states. Compared to the ref's, Agents provide independent and asynchronous access to data residing at individual locations.
\item {\it Atoms} share changing states in an independent and asynchronous manner between threads. 
\item A {\it Var} ``refer to a mutable storage location that can be dynamically rebound (to a new storage location) on a per-thread basis.'', according Clojure's official website.
\end{enumerate}
    
   
%     \item Scripting:\\
%         Clojure is a dynamic language. \cite{hickey2009clojure}
%     \begin{enumerate}
%         \item  command-line shell environment called the REPL, which stands for Read, Evaluate, Print Loop. This refers to the fact that the REPL first reads an expression from the user, evaluates that expression, and prints out the result before looping back to the beginning. (find ref and confirm)
%     \item Dynamic polymorphism ((http://clojure.org/rationale))
% \end{enumerate}
% https://en.wikipedia.org/wiki/Dynamic_programming_language





% ==================================

\section{Phase 3: Primitive Types} \label{rex}

% ==================================

\question{Question}
{\it What primitive types are available? (integer? boolean?) What kinds of values can they have? (0? -0? true? -00.30?) What range of values can they have? (0 to infinity? -231 to 231?) How much memory does it each type use? (Bits and bytes - not all languages will let you know this. Some languages, like Python, make the integer grow to fit your needs.). Write a program to demonstrate as much of this as possible. Give a (short) explanation in comments. Remember to include your citation(s). }

\question{Overview}

{\it Scalar literal} is the closest thing to the familiar primitives. Since Clojure code runs on JVM, its data types are Java data types.


Clojure (Lisp, really) has the philosophy of code-as-data, meaning that its code is literally its own data structures and atomic values \cite{emerick2012clojure}. The {\it reader} is used to interpret these data structure out of textual code; there are "noncollection values", or scalar literals, in the reader syntax. Some of the scalar literals do not have corresponding concepts in languages like Java or python.


Clojure's scalar literals include:
\begin{itemize}
\item Numbers
\item Characters
\item Strings
\item Booleans
\item nil
\item Keywords
\item Symbols
\item Regular expressions
\end{itemize}


\part{Numbers}

Clojure by defaults stores integers as Long, and floating point numbers as Double. Clojure can intelligently uses \texttt{java.lang}\texttt{.BigInteger} and {java.lang.BigDecimal} so that the maximum degree of precision is preserved; there is no limit to how big (or small) numbers can be in Clojure \cite{fogus2011joy}. Consequently, there is no bound to the size of integers and floating point numbers.

\point{Rationals}
A rational is a number with a nominator and a denominator, both of type arbitrary-precision integers. Rationals retain more precision than floating point numbers \cite{fogus2011joy}.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; Integers
user> (class 42) ;; get the class of literal 42
java.lang.Long
user> Long/SIZE  ;; get static member SIZE of class 
64               ;; java.lang.Long, signed int
                 ;; 64 bits or 8 bytes

;; integer of arbitrary precision
;; N to force to use BigInt
user> (class 42N)
clojure.lang.BigInt

;; Floating points
user> (class 42.0)
java.lang.Double
user> Double/SIZE
64               ;; Both Long and Double are 64 bits
                 ;; IEEE floating point
                 ;; 64 bits or 8 bytyes
                 
;; Floating point of arbitrary precision
;; M to force to use BigDecimal
user> (class 42M) 
java.math.BigDecimal

;; Rational
user> (class 2/42)
clojure.lang.Ratio
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in\\
Then do \texttt{C-c C-k} to compile the current buffer\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
Reference is here \cite{fogus2014joy}, here \cite{emerick2012clojure} and here \cite{interop}. \\
\hline
\end{tabular}

\point{Special cases of numbers}
Clojure deals with special cases without surprises. 


\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; comparing 0 to -0
user> (= 0 -0)
true

;; leading 0's are ignored
user> (class -00.30)
java.lang.Double
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in\\
Then do \texttt{C-c C-k} to compile the current buffer\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
\end{tabular}

% ======================================
\part{Characters}
% ======================================
Clojure character literals are denoted by a backslash prefix \cite{fogus2014joy}. They are stored as Java characters, and Unicode characters are included, too. Since the size of a char is 16 bits, the range is from \texttt{\textbackslash u0000} to \texttt{\textbackslash uffff} \cite{oraclechar}.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; Of class java.lang.Character
clojure-noob.core> (class \u0042)
java.lang.Character
;; Unicode character
clojure-noob.core> \u0042
\B
clojure-noob.core> Character/SIZE
16  ;; 16 bits, 2 bytes
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
From \cite{fogus2014joy}.\\
\hline
\end{tabular}


\part{String}
Clojure strings are java strings. See comments in the code example for caveats in REPL environment.


\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
(defn new-line
  []
  ;; A string is contained between two double quotes.
  ;; Including newlines.
  (println "I am a
oops... string...\n \toops"))
\end{minted}
\\
\hline
\begin{minted}{clj}
;; Run the new-line function
clojure-noob.core> (new-line)
I am a
oops... string...  ;; there IS a newline
 	oops
nil

;; But REPL escapes backslash newline literals
clojure-noob.core> (def a-string"Hi\nthere")
#'clojure-noob.core/a-string
clojure-noob.core> a-string
"Hi\nthere"     ;; see
;; But the string does print as expected
clojure-noob.core> (println a-string)
Hi
there
nil
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Create a clj file and \texttt{C-c M-n} to switch to current namespace, \texttt{C-c C-k} to compile. Also, enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
From \cite{fogus2014joy}.\\
\hline
\end{tabular}

\part{Boolean}
Java's true and false; they are not capitalized, nor are they represented by integers. Interestingly, Oracle documentation suggests that although booleans represent 1 bit of information, its size is not precisely defined \cite{oraclechar}.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; Cannot cast true into Integer
clojure-noob.core> (cast Integer true)
ClassCastException Cannot cast java.lang.Boolean
to java.lang.Integer java.lang.Class.cast 
(Class.java:3369)
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
From \cite{rathore2011clojure}.\\
\hline
\end{tabular}


% =================
\part{nil}
% =================
The famous null in Java. Logically equivalent to false. Some properties are shown below in the code example.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; Does not equate to false
clojure-noob.core> (= nil false)
false
;; But logically is
clojure-noob.core> (if nil () (println "False!"))
False!  ;; else statement prints False!
nil     ;; every form evaluates to something
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
From \cite{rathore2011clojure}.\\
\hline
\end{tabular}


\part{Symbols}
Symbols are objects that are often evaluated into something else \cite{fogus2014joy}.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; define a symbol called a-string
clojure-noob.core> (def a-string"Hi\nthere")
#'clojure-noob.core/a-string
;; evaluate that symbol, returns 
;; a string, instead of the symbol itself
clojure-noob.core> a-string
"Hi\nthere"
;; But the evaluation can be suppressed
clojure-noob.core> `a-string ;; by ` 
clojure-noob.core/a-string
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
Adapted from \cite{fogus2014joy}.\\
\hline
\end{tabular}

\part{Keyword}

A keyword is similar to symbol, but a keyword evaluates to itself. Keywords are fare more commonly used than symbols \cite{fogus2014joy}.


\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; a keyword called mass-wasting
clojure-noob.core> :mass-wasting
;; evaluates to itself
:mass-wasting
;; usage as map keys
;; rocks symbol evaluates to a map, constructed by {}
;; ls is the key
clojure-noob.core> (def rocks {:ls "limestone"})
#'clojure-noob.core/rocks
clojure-noob.core> (get rocks :ls)
;; limestone is the value
"limestone"
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
Adapted from \cite{fogus2014joy}.\\
\hline
\end{tabular}


\newpage
\part{Regular expressions}
In Clojure, a regular expressions is a string prefixed with a hashtag \cite{rathore2011clojure}. Although the usage of regular expression is far beyond the scope of this humble composition, Clojure's regular expression uses Java's regex. Regular expression is listed as one of the scalar literals in \cite{rathore2011clojure}, and called ``first-class data type'' in \cite{fogus2014joy}. 



\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
clojure-noob.core> (class #"gneiss")
java.util.regex.Pattern
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
Inspired by \cite{fogus2014joy}.\\
\hline
\end{tabular}

\vspace{20pt}
{\it Note}: this section takes advantage of REPL environment for ease of testing, so a complete program is not provided.

\section{Phase 4: Composite Types}

{\it What composite types can you make? (tuple, struct, matrix...) List 3 or more. What formal definitions of constructors from your book and lecture do they each match? (record, cartesian product, array, union ...) If the type constructor has options, what choices did your language make? Give an example program using each of these type constructors?}

\part{Answers}

Collections are very important Clojure composite types. Clojure collections are all immutable. The elements in some collections can be accessed via keys, but no values can be set by keys. Clojure has four basic collection types:
\begin{itemize} 
\item Lists
\item Vectors
\item Maps
\item Sets
\end{itemize}

% ==========
\part{Lists}
% ==========


Fun fact: the name Lisp  comes from list processing \cite{fogus2014joy}.

Clojure's list is a kind of mapping; it is also a recursive type (being a singly linked list). It is possible to access an item on the n-th index through \texttt{nth}; that is not the intended use of Clojure lists, because Clojure will do an O(n) traversal from the head \cite{fogus2014joy}. Instead, lists are mainly used for denoting forms in Clojure \cite{fogus2014joy}. The head of the list is resolved into ``a function, macro or special operator'' , and the rest of the elements are evaluated in order, as parameters \cite{fogus2014joy}.

Since collections in Clojure are immutable, the size of the list is fixed, and there is no limit in length when created \cite{fogus2014joy}. A list can hold elements of any type (heterogeneous), including other collections. Operations are usually done to the head of a list, such as \texttt{conj}.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; Constructed by ()'s
;; Yes the famous (((((()))))))'s
;; (if...) is a list, as an element in (def....) list
;; So lists can contain objects of different types
;; Even other collections
clojure-noob.core> (def eg (if {} :truethy))

;; index from 0 to n-1, inclusive
;; Range is defined on non-negative integers
;; Else: IndexOutOfBoundsException from java
;; or a specified handler
clojure-noob.core> (nth (if nil "a") 1)
nil

;; Adding to the head of the list
;; put c in front of (a,b)
;; ' symbol suppresses evaluation
;; of list ("a" "b"), else error will occur
clojure-noob.core> (conj '("a" "b") "c")
;; the expr (conj ...) evaluates to a new list
;; the old list is still immutable 
("c" "a" "b")

;; Empty test
user=> (empty? ())
true

;; get length
;; Need to suppress evaluation of the list
user=> (count '(1 42))
2
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
See \cite{fogus2014joy} and \cite{empty}.\\
\hline
\end{tabular}




\newpage
% ===========
\part{Vectors}
% ===========

Clojure vectors belong to mapping, since there is a correspondence from type integer (indices) to vector elements, which can assume any type (heterogeneous) \cite{fogus2014joy}. The length of a vector is fixed once made; but there's no limit in length. An empty vector is not nil.

\point{Tuples in Clojure}
Tuples are commonly built with vectors in Clojure \cite{rathore2011clojure}.


\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; Constructed by [] `(literal syntax)
;; as in [:a "b" 42]: different types
;; multi-dimension is also possible
;; index from 0 to n-1, inclusive
;; Range is defined on non-negative integers
;; Else: IndexOutOfBoundsException from java
;; or a specified handler `(the (print.. ))
;; nth applies to vectors also
user=> (nth [:a "b" 42] 3 (println "bad index"))
bad index   ;; the handler prints
nil         ;; println's return value

;; alternative constructors
;; vector's arguments have an arbitrary length
clojure-noob.core> (vector 42 "42")
[42 "42"]
clojure-noob.core> (vec (range 2))
[0 1]       ;; vec takes a sequence 

;; Example operation: appending an element
;; The expression (conj... ) evaluates 
;;     to a new, longer vector
;; But the old vector itself is still immutable.
user=> (conj [:a :b] :c)
[:a :b :c]

;; Empty test
user=> (empty? [])
true

;; get length
user=> (count [])
0
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
See \cite{fogus2014joy}, \cite{rathore2011clojure} and \cite{empty}.\\
\hline
\end{tabular}



\newpage

% ===========
\part{Maps}
% ===========

Map is, by name, a kind of mapping. An element in a map consists of a key-value pair \cite{fogus2014joy}. Clojure's map can have any type for both keys and values (heterogeneous) \cite{fogus2014joy}.
Since collections in Clojure are immutable, the size of the map is fixed throughout its lifetime. An empty map is not the same as nil \cite{fogus2014joy}.

The keys in a map should not duplicate \cite{rathore2011clojure}. A map can be sorted or unsorted (hashmap) \cite{rathore2011clojure}.

\begin{tabular}{|p{\textwidth}|}
\hline
\begin{minted}{clj}
;; {} constucts a map
;; with key-value pairs
;; {:answer 42 :who "DeepThought"} is the map
;; Recall :answer, :who are keywords
clojure-noob.core> (def ultimap {:answer 42 :who "DeepThought"})
#'clojure-noob.core/ultimap
;; Access a value through a key
clojure-noob.core> (get ultimap :answer)
42

;; Different types of keys and values are possible
;; Can have multidimensional maps
;; But the popular keys are still keyword type
;; note "a" and the first 42 is a pair;
;; for readability, the expression can also be
;; (def rand-map {"a" 42, 42 []})
clojure-noob.core> (def rand-map {"a" 42 42 []})
#'clojure-noob.core/rand-map

;; Get all the keys as a list
clojure-noob.core> (keys rand-map)
("a" 42)

;; Get all the values as a list
clojure-noob.core> (vals rand-map)
(42 [])

;; Empty test
user=> (empty? {})
true

;; Length is now the number of pairs
clojure-noob.core> (count rand-map)
2   ;; not 4

;; Sidenote of Clojure's truthiness
;; if empty map, then return :truthy
clojure-noob.core> (if {} :truthy)
:truethy    ;; {} looks to if like true
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
Adapted from \cite{fogus2014joy} and \cite{empty}.\\
\hline
\end{tabular}



\part{Cartesian Products}


\point{Sets}


Clojure's set is a collection of objects without duplication \cite{rathore2011clojure}. Since a set can contain any data type (heterogeneous), it is a Cartesian product. It can come in a sorted or unsorted flavour \cite{rathore2011clojure}. There is no obvious way to get set elements by name, because they technically don't have any, and nor is there a limit to the number of elements created in the set.


\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; Constructed by #{} (literal)
user=> (def rocks #{:gneiss :slate :slate})
;; Duplicated elements are not allowed
IllegalArgumentException Duplicate key: :slate

;; Making a set from other collections
user=> (set [42 42 42])
#{42}   ;; duplicates eliminated 

user=> (def rocks #{:gneiss :slate :schist})
#'clojure-noob.core/rocks       ;; OK

;; Empty test
user=> (empty? #{})
true

;; There seems to be no name access 
;; contains? checks if the given key is present
user=> (contains? rocks 0)
false
user=> (contains? rocks :slate)
true

;; get length
user=> (count rocks)
3
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
See \cite{rathore2011clojure} and \cite{empty}.\\
\hline
\end{tabular}



\point{Interoperability with Java classes}

Clojure can use Java classes \cite{fogus2014joy}, a feature called {\it interoperability}. Clojure can access Java classes and their members, and even create new instances. Clojure provides mechanisms like \texttt{reify} and \texttt{deftype} to emulate Java interfaces \cite{fogus2014joy}.

A class contains objects of different types; it is a Cartesian product.


\begin{tabular}{|p{0.99\textwidth}|}
\hline
\begin{minted}{clj}
;; Create an instance of Point class
;; The dot behind Point denotes creation 
;; of an instance 
clojure-noob.core> (java.awt.Point. 1 1)
#object[java.awt.Point 0x37a2bc27 "java.awt.Point[x=1,y=1]"]
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
Adapted from \cite{fogus2014joy}.\\
\hline
\end{tabular}



\section{Higher order functions, anonymous functions, portability and infinite lists}
% ==========================
\question{Phase 5: Higher order functions}
% ==========================
\point{12. higher order functions. Haskell supports these in many ways. C lets you pass functions into a function which is higher order but that is it.}

A higher order function is defined such that it takes functions as arguments, and / or it returns a function as a result \cite{fogus2014joy} (Ch. 7.1.2).

\part{Functions as arguments}

There are three important high order functions in Clojure \cite{fogus2014joy} (Ch 6.3.4). 

\begin{itemize}
\item \texttt{map}:  applies the function passed in as argument to the provided sequence, and returns another sequence as the result. 
\item \texttt{reduce}:  applies the given function to the first two items in the collection; it then take the intermediate result and apply the function with the third item and so forth.
\item \texttt{filter}: applies the function to every item in the collection; if function returns false for an item, this item is filtered out.
\end{itemize}



\begin{tabular}{|p{0.99\textwidth}|}
\hline
\begin{minted}{clj}
;; =============== map ===================
;; dec decreases the value of argument by 1;
;; dec as a function, is one of the two arguments
;; map applies dec to every element in [0 42]
;; A new sequence is returned.
user=> (map dec [0 42])
(-1 41)

;; using map to get columns of a 2D array
user=> (map vector [:x :1] [:y :2] [:z])
;; map stops when one of the sequence runs out
([:x :y :z]) ;; so no [:1 :2] here

;; =============== reduce ================
;; Go Gauss!
;; range returns a lazy sequence from 1 to 100, inclusive
;; Step 1: 1 + 2 = 3
;; Step 2: 3 + 3 = 6
;; Step 3: 6 + 4 = 10 and so forth
;; The sequence is "reduced" to 5050, the sum of all items
user=> (reduce + (range 1 101))
5050

;; ============= filter ==================
;; even? is a function
user=> (filter even? (range 41 43))
;; between 41 and 42, inclusive
(42) ;; 42 is even!
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
Adapted from \cite{empty}.\\
\hline
\end{tabular}



\part{Functions as return values}

Clojure has three important functions in this category \cite{fogus2014joy}:
\begin{itemize}
\item \texttt{comp} takes a set of functions and return a composition function. The returned function will apply the set of functions from the right most to the left.
\item \texttt{partial} takes a function f that expects n arguments, and x arguments of f. \texttt{partial f args}. Returns a fn that takes y arguments, such that $x + y = n$.
\item \texttt{complement} returns the opposite truth value for the argument function passed in.
\end{itemize}

It is also possible to define a new function that returns a function.

\begin{tabular}{|p{0.99\textwidth}|}
\hline
\begin{minted}{clj}
;; =============== comp ===================
;; First, -84/2 = -42
;; Second, -(-42)
;; Applied from right to left
user=> ((comp - /) -84 2)
42

;; =============== partial ================
;; Partial returns a fn: "4" + ?
;; then fn found its other arg to be "2"
;; very nice
user=> ((partial str "4") "2")
"42"

;; ============= complement ==================
;; (complement odd?) effectively returns an even? function
user=> (filter (complement odd?) (range 41 43))
(42)
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
Definitions adapted from \cite{empty}.\\
\hline
\end{tabular}


\question{Phase 5: Anonymous functions}

\point{14. Anonymous functions}

As a functional language, Clojure uses a special form to build anonymous, or unnamed, functions \cite{fogus2014joy}. There is also a reader feature to define in-place functions using \texttt{\#()}.

\begin{tabular}{|p{0.99\textwidth}|}
\hline
\begin{minted}{clj}
;; This function has no name
 ((fn [n]     ;; a vector of function params, n
    (* 3 n))            ;; return value = 3 * n
    2)                  ;; passing in param
    
Output
6                       ;; return value

;; ... which is the same as using #()
(#(* 3 %) 2)  
;; The % implicitly declares the accepted argument
\end{minted}
\\
\hline
To run: use Emacs and cider see \cite{brave2015}\\
\hline
Adapted from \cite{koan} and \cite{fogus2014joy}.\\
\hline
\end{tabular}



\question{Phase 5: Portability}

{\it 47. Does it claim to be portable like Java? How portable is it?}

Rich Hickey, the designer of Clojure, said that Clojure was intended as a hosted language .  Clojure can use Java libraries easily. This hosted feature allows Clojure be used wherever Java is used \cite{hickey}. Consequently, Clojure is very portable because JVM is; portability is one of the key features of Clojure. Besides JVM, Clojure can also be hosted on CLR (Common Language Runtime) and JavaScript.


\question{Phase 5: Infinite Lists}

\point{13. Infinite Lists}

Yes Clojure has those. With lazy evaluation, one is encouraged to \texttt{take} a finite number of items from the infinite list without breaking the universe.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; (range) returns a lazy sequence,
;; staring from the default 0 to infinity
;; Run this and see what infinity means
usr => (println (range))
;; or, just take the first two in the coll
usr => (take 2 (range))
(0 1)
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
Definitions adapted from \cite{empty} \cite{fogus2014joy} (Ch.6.3.4).\\
\hline
\end{tabular}



\section{Phase 6: Dynamic typing, scope \& regex}


\point{2. static vs dynamic typing. duck typed?}

Clojure, like Lisp, is dynamically typed\footnote{\url{https://www.quora.com/Is-Scala-faster-than-Clojure}. Michael Klishin seems to be an experienced developer of Clojure}. Lisp seems to be the first language that features dynamic typing \cite{tratt}.  There are no mutable states in Clojure \cite{fogus2014joy}, so the following example is used to illustrate dynamic typing.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
usr=> (defn foo [x y] (/ x y)) ;; x / y
usr=> (foo \a 1) ;; char 'a' and int 1
ClassCastException java.lang.Character cannot be 
cast to java.lang.Number  clojure.lang.Numbers.
divide (Numbers.java:159)
;; So the exception came from divide operator,
;; not the type checking of foo()
;; foo() does not require args to be certain types
;; so clojure is ducked typed as well.
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
\end{tabular}



\newpage

\point{3. untyped vs weakly typed vs strongly typed}

Clojure is strongly typed, at least stronger than Java; see the tests below.

\begin{tabular}{|p{0.9\textwidth}|}
\hline
\begin{minted}{clj}
;; Clojure is typed, see the cast exception
usr=> (/ \a 1)
ClassCastException java.lang.Character cannot be cast to
java.lang.Number  clojure.lang.Numbers.divide 
(Numbers.java:159)
;; Clojure being unable to cast character into int
;; => Stronger than Java

usr=> (/ 1 4.2)
0.23809523809523808
;; Coerced 1, an int, into floating point
;; => weaker than Ada
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in to start REPL\\
Enter code at the prompt.\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
\end{tabular}





\part{8. static and/or dynamic scope.}

Clojure supports both static and dynamic scopes \cite{fogus2014joy}. 

\texttt{let} defines locals of static scope.


\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
(def x 3)           ;; binds global var x to 3
;; (let [bindings*] exprs*)
;; symbols are resolved within 
(let [x 1]          ;; binds x with 1
  (let [x 42]       ;; binds x with 42
    (println x))    ;; in the inner let block
  (println x))      ;; in the outer let block
;; global var unchanged
(println x)
\end{minted}
\\
\hline
\begin{minted}{clj}
42
1
3
\end{minted}
\\
\hline
From \cite{empty} \cite{fogus2014joy} (Ch.10.6.4).\\
\hline
\end{tabular}

\texttt{binding} takes a dynamic var, and the new binding affects the call stack \cite{binding}. \texttt{binding} can allow a var to be shared safely between threads; each thread pushes / pops its own local binding of the same var, leaving the global var unchanged, nor does its local binding affect other threads. The following example only shows one simple use case of binding. It is not within the scope of this report to present the advantage of dynamic scoping in a concurrent context.



\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
(def y 3)
#'clojure-noob.core/y
usr => (binding [y 3] (println y))
IllegalStateException Can't dynamically bind 
non-dynamic var: clojure-noob.core/y 
clojure.lang.Var.pushThreadBindings (Var.java:320)

;; has to be declared dynamic 
usr => (def ^:dynamic x 1)
usr => (binding [x 2] (println x))
2   ;; prints x is 2
nil ;; binding returns
usr => (println x)
1   ;; outside binding, x is still 1
\end{minted}
\\
\hline
From \cite{binding} and \cite{empty} (Ch.10.6).\\
\hline
\end{tabular}


% {\it Give a brief history of the language and its current state (counts as one question). This question does not require additional code examples or arguments to back up your reasoning. }

\part{9. parameter passing mechanisms}

Like Java, Clojure passes arguments by value; in the case of references, they are passed by references pointing to objects \cite{pass}. One way to test it is to use \texttt{identical?}, which decides if the two arguments are the same object \cite{empty}.


\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; define a global z with a vector
usr => (def z [1])
#'clojure-noob.core/z
;; foo takes a parameter 
;; foo uses identical? to check
usr => (defn foo [a] (identical? a z))
#'clojure-noob.core/foo
usr => (foo z)
;; the z passed in and the global z are the same obj
true    
\end{minted}
\\
\hline
A humble concoction of mine.
\\
\hline
\end{tabular}

\newpage








% 10.23.2015


\part{10. evaluation strategy}

Clojure is partly a lazy language \cite{fogus2014joy}.

Normally, Clojure uses {\it eager} evaluation, which starts from the innermost parenthesis and works its way outwards. Notice that in Clojure, the precedence of operators is not a problem because of all the \texttt{(((((())))))}'s.


\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; 4 + 2 is eagerly evaluated first
;; then 7 * 6
usr => (* 7 ( + 4 2))
42
\end{minted}
\\
\hline
A humble concoction of mine.
\\
\hline
\end{tabular}

When dealing with sequence types, Clojure uses lazy evaluation. For instance, Clojure only ``takes'' what it needs:

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; (range) is a sequence of 0 to infinite int's
usr=> (take 2 (range))
;; universe is still intact because Clojure is lazy
(0 1)
\end{minted}
\\
\hline
A humble concoction of mine.
\\
\hline
\end{tabular}



\point{48. What types of tokens does it have? (literals, keywords, symbols)}

See Section \ref{rex} on primitive types. Clojure does have various number, char, string literals, as well as keywords and symbols.



\point{6. Reflection (computational and structural)}

Clojure has an API for clojure.reflect \cite{reflect}. It mainly reflects on the host types, such as the class of an instance. Clojure's reflection is computational. There are two ways to do reflection: 

\begin{itemize}
\item Reflects on a class that implements TypeReference (type-reflect).
\item Get the class of an instance, or reflect on the class itself.
\end{itemize}

Reflection can provide a map with keys like :bases and :members.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; reflect on the number 42
;; getting the base classes of 42
clojure.reflect=> ((reflect 42) :bases)
;; returns a set of java classes
#{java.lang.Comparable java.lang.Number}
\end{minted}
\\
\hline
See the API at \cite{reflect}.
\\
\hline
\end{tabular}


\point{18. Brief history of Clojure}


\begin{itemize}
\item Clojure was created by Rich Hickey in 2007\footnote{\url{https://github.com/clojure/clojure/commits/1.0.x?page=30}}. It took Hickey about two years to write it before the initial release.
\item Clojure compiles down to Java bytecode\footnote{\url{https://www.youtube.com/watch?v=P76Vbsk_3J0&index=4&list=WL}. A talk by Rich Hickey}.
\item Built from Hickey's personal revelations in working as a software engineer, Clojure was created to be the following because C++ / C\# / Java are not good enough\footnote{\url{http://clojure.org/rationale}}.
\begin{itemize}
\item A functional language, especially Lisp-like.
\item symbiotic with a popular platform for portability and practicality.
\item concurrency-friendly.
\end{itemize}
\item Yes. People are hiring for Clojure, and the pay is pretty good\footnote{\url{https://gooroo.io/analytics/skill/Clojure\#.VirsSLzSxnk}}. Clojure jobs come from start-ups like Cognitect\footnote{\url{http://cognitect.com}}, and of course there are more. A search on LinkedIn revealed a variety of job opportunities\footnote{\url{https://www.linkedin.com/job/clojure-jobs/?sort=relevance\&page_num=1\&trk=jserp_pagination_1}} in areas of web development, data science and more. 
\end{itemize}


% 10/31/2015

\point{26. Can you directly access or manipulate the bits of an integer value? What operations are possible?}

According to Clojure's official site\footnote{\url{http://clojure.org/data_structures}}, it can do bit-and, bit-or, bit-xor, bit-not, bit-shift-right and bit-shift-left. The following example uses bitwise and \& bitwise shift right.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; from a 206 lab
;; get_byte - Extract byte n from word x
;; example: get_byte(0x12345678, 1) = 0x56
(defn get-byte
  [x n]
  (format "0x%x" 
        (bit-and 
         (bit-shift-right x (* 8 n)) 
         0xff)))
user> (get-byte 0xdeadbeef 0)
"0xef"
\end{minted}
\\
\hline
See \cite{empty}.
\\
\hline
\end{tabular}


\point{25. What math operations can you do on numbers? Is this different for characters and other integer-like types? Does it allow math that makes no sense?}

Clojure's core\footnote{\url{https://github.com/clojure/clojure/blob/bdc752a7fefff5e63e0847836ae5e6d95f971c37/src/clj/clojure/core.clj}} supports: \texttt{+ - * / inc dec quot rem min max}. It also supports comparisons: \texttt{== < <= > >= zero? pos? neg?}. Outside the core, clojure.math.numeric-tower provides exponents, ceiling, floor functions and more\footnote{\url{https://github.com/clojure/math.numeric-tower}}. There is also the clojure.math.combinatorics to do discrete maths\footnote{\url{https://github.com/clojure/math.combinatorics}}.


\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; \a is the character 'a'
user> (+ \a 1)
ClassCastException 
\end{minted}
\\
\hline
No Clojure does not do nonsense math
\\
\hline
\end{tabular}

\point{30. What about dangling else? Is it a problem? If yes, how does it handle it? if not, why is it not a problem? It is a problem in both C and Java but not in Haskell}

Since Clojure has all expressions, \texttt{if} always returns something. The argument in case of \texttt{else} condition is optional. Specifically, if nothing is supplied to the \texttt{else} condition, Clojure defaults to return nil. It is a problem in that user does not have to specify anything for the dangling else; on the other hand, something is always returned.


\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; prototype: (if test then else?)
;; then clause = "try dangling"
;; else? is missing here
user> (if false "try dangling")
nil ;; default
\end{minted}
\\
\hline
See clojure.core's documentation at \cite{empty}.
\\
\hline
\end{tabular}


\point{39. Does it use short circuit evaluation? Are these operators with options or not as you like?}

Clojure does short-circuit evaluation for \texttt{and} and \texttt{or}. Google searches yielded no trace of short-circuiting being optional.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
user> (or true 
    (do (println "no short-circuit")) 
    "see above")
true
;; nothing prints so does short circuit
;; the operator and does the same thing
;; (and false ....) short circuits
\end{minted}
\\
\hline
See\footnote{\url{http://stackoverflow.com/questions/8190417/does-clojure-have-short-circuit-logic}}
\\
\hline
\end{tabular}


\point{41. Does it differentiate between/allow use of statements or expressions?}

Clojure only uses expressions; no statement exists in Clojure\footnote{http://clojure.org/evaluation}.



\point{43. Does it use infix, prefix, postfix, mixfix operators? function calls? some combo of them?}

Prefix 100\% of the time, all the time\cite{fogus2014joy}! All function calls, unary, binary operators etc. are all prefix.


\point{52. What comment stypes does it support?}

Clojure has two ways of commenting:
\begin{enumerate}
\item commenting out a line with \texttt{;}
\item commenting out a form with \texttt{\#\_}
\end{enumerate}

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
; This is a comment
;; but using two of ;'s is more common
;; #_ comments out a pair of ()
user> (if true #_(:answer) (+ 1 41))
42
;; #_ works for [] as well
user> (if true #_[0] [42])
[42]
\end{minted}
\\
\hline
See\footnote{\url{}}
\\
\hline
\end{tabular}



\point{16. Overloading of method names or operators}

In Clojure, operators are plain functions \cite{fogus2014joy} (p. 13). Overloading is possible for both methods and operators. In practise, it is better to use multimethods than simply overloading functions, especially basic operators like +\footnote{http://clojure.org/multimethods}.

\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
;; attempt to overload + operator
user> (defn + [x] 0)
;; compiler gives a warning
WARNING: + already refers to: #'clojure.core/+ in 
namespace: user, being replaced by: #'user/+
#'user/+
;; but the evil definition is used anyways
user> (+ 3)
0
;; what an awful thing to do
\end{minted}
\\
\hline
My humble concoction 
\\
\hline
\end{tabular}

Clojure also comes with overloaded methods. Clojure does arity overloading within a single function definition. Below is a snippet of the source code for + operator in clojure.core


\begin{tabular}{|p{0.98\textwidth}|}
\hline
\begin{minted}{clj}
(defn +
  "Returns the sum of nums. (+) returns 0. Does not auto-promote
  longs, will throw on overflow. See also: +'"
  {:inline (nary-inline 'add 'unchecked_add)
   :inline-arities >1?
   :added "1.2"}
  ([] 0)            ; no argument
  ([x] (cast Number x)) ; one argument
  ([x y] (. clojure.lang.Numbers (add x y))) ; 2
  ([x y & more]                              ; or more
     (reduce1 + (+ x y) more)))
\end{minted}
\\
\hline
From \url{https://github.com/clojure/clojure/blob/master/src/clj/clojure/core.clj}
\\
\hline
\end{tabular}


% 11/6/2015

\part{49. What are the regular expressions for its tokens? (Give a regular expression to describe each category of literals - integers, booleans, etc).}




\begin{tabular}{|p{0.98\textwidth}|}
\hline
\begin{minted}{clj}

(def ^Pattern int-pattern #"([-+]?)(?:(0)|([1-9][0-9]*)|
0[xX]([0-9A-Fa-f]+)|0([0-7]+)|
([1-9][0-9]?)[rR]([0-9A-Za-z]+)|
0[0-9]+)(N)?")
(def ^Pattern ratio-pattern #"([-+]?[0-9]+)/([0-9]+)")
(def ^Pattern float-pattern #"([-+]?[0-9]+(\.[0-9]*)?
([eE][-+]?[0-9]+)?)(M)?")



\end{minted}
\\
\hline
Clojure reader.clj can be found at \url{https://github.com/clojure/tools.reader/blob/master/src/main/clojure/clojure/tools/reader/impl/commons.clj}
\\
\hline
\end{tabular}




\point{45. What control structures does it use? For instance C has an old style ?: for selection.}

Clojure has two types of flow control: normal and exceptional\footnote{\url{https://clojuredocs.org/quickref}}.


Normal types of control structures include the usual if, if-let, when, when-let, cond, do, eval, loop and more. Exceptional circumstances include assert and try-catch.

\begin{tabular}{|p{0.98\textwidth}|}
\hline
\begin{minted}{clj}
user=> (if nil "not" "is nil")
"is nil"

;; when-let is useful for dealing with empty collection
user=> (defn get-head
  #_=> [coll]
  #_=> (when-let [handle (seq coll)]
  #_=> (first handle)))
#'user/get-head
user=> (get-head [1,43,34])
1
user=> (get-head [])
nil
\end{minted}
\\
\hline
\begin{minted}{clj}
;; An example for when
(defn train ;; define a function, train
    [x]     ;; that takes one argument
    (when (pos? x)  ;; when x is positive
      (println "Choo choo!")
      ;; recur is a special form that does
      ;; __tail recursion__
      (recur (dec x)))) 
\end{minted}
\\
\hline
\begin{minted}{clj}
clojure-noob.core> (train 3)
Choo choo!
Choo choo!
Choo choo!
nil
\end{minted}
\\
\hline
See \url{https://clojuredocs.org/clojure.core/when-let}
\\
\hline
\end{tabular}

\point{31. What is the order or precedence for all the math operators? relational operators? any other operators? This requires an answer but not code or an argument. It definitely requires a reference.}

This question is not a problem in Clojure; it does not have precedence rules because it is fully parenthesized \cite{fogus2014joy}.


11/13/2105
\begin{tabular}{|p{0.8\textwidth}|}
\hline
\begin{minted}{clj}
(defmulti greeting
  "The multimethod greeting"
  (fn [x] (x "language")))
(defmethod greeting "English" [_]
  "Returns the appropriete greeting"
  "Hello!")
(defmethod greeting "Deutsch" [_]
  "Hallo!")
(defmethod greeting :default [params]
  (throw (IllegalArgumentException.
  (str "Kein " (params "language")))))
  
(def english-map {"id" "1" "language" "English"})
(def deutsch-map {"id" "1" "language" "Deutsch"})
(def espano-map {"id" "3" "language" "Espano"})
\end{minted}
\\
\hline
\begin{minted}{clj}
clojure-noob.core> (greeting deutsch-map)
"Hallo!"
clojure-noob.core> (greeting espano-map)
IllegalArgumentException Kein Espano 
clojure-noob.core/eval3459/fn--3460 (core.clj:27)
\end{minted}
\\
\hline
To run: in Emacs, \texttt{M-x}, select cider-jack-in\\
Then do \texttt{C-c C-k} to compile the current buffer\\
For using cider in Emacs, see \cite{brave2015}\\
\hline
Adapted from \cite{clojuredocmulti}\\
\hline
\end{tabular}



\bibliographystyle{plain} \bibliography{bib} 

% http://clojure.org/functional_programming
% http://clojure.org/state
\end{document}